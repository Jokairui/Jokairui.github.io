---
layout:     post
title:      Java虚拟机是如何加载Java类的
subtitle:   类的加载过程
date:       2019-09-16
author:     Khirye
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 深入拆解Java虚拟机
---
#### 如何定义"加载"

所谓"加载"，是指将一个Java class文件加载到内存中，变成内存中一个真正可用的类对象

将一个class文件加载到虚拟机中，一共要经过以下步骤：

1. 加载
2. 链接
3. 初始化

Java中的类型可以分为两大类：

1. 基本类型： 它们是有虚拟机预定义好的类型，就是Java中的8大基本类型
2. 引用类型：细分为4种，类，接口，数组类和泛型参数，由于泛型参数在编译过程中会被擦除，因此虚拟机只有前三种，其中数组类由Java虚拟机直接生成，剩余两种则有自己对应的字节流



#### 加载

加载，即查找字节流，且据此创建类的过程。

Java虚拟机需要借助类加载器来完成查找字节流的过程。

##### 启动类加载器（Boot Class Loader）

所有类的祖先：启动类加载器，它由C++实现，没有对应的Java对象，因此Java中只能用null来指代。

除启动类加载器外，所有的类加载器都是java.lang.ClassLoader的子类，因这些类加载器需要由其他的类加载器（比如启动类加载器）加载到虚拟机中才能使用

在Java9之前，启动类加载器负责加载最为基础、最为重要的类，如JRE lib下的类（以及由虚拟机参数 -Xbootclasspath 指定的）

##### 扩展类加载器（Extension Class Loader）

继承至启动类加载器，负责加载相对次要但又通用的类，如JRE lib/ext 目录下的类（以及由系统变量 java.ext.dirs 指定的类）

Java9中，扩展类加载器改名为平台类加载器（Platform Class Loader），Java SE中除了少数几个重要的模块外，其余所有的模块都由平台类加载器加载

##### 应用类加载器（Application Class Loader）

继承至扩展类加载器，负责加载应用路径（即ClassPath下）的类

##### 双亲委派模型

当一个类加载器收到加载请求时，会将请求转发给父类加载器，在父类加载器没有找到请求的类时，才通过自身去尝试加载

##### 自定义类加载器

除了以上Java核心类库提供的类加载器之外，我们还可以自定义自己的类加载器

Java中类的唯一性由 **加载它的类加载器 + 类的全名** 来确定，因此可以通过不同的类加载器产生一个类的不同版本



#### 链接

链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。

1. 验证

   验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件

2. 准备

   准备阶段的目的，则是为被加载类的静态字段分配内存。除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。在Class文件加载到虚拟机之前，所有的方法和变量都没有具体的内存地址，因此Java编译器会为他们生成一个符号引用。

3. 解析

   解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

##### 符号引用

符号引用可以用一个例子来理解，例如我们称一座房子为"Tony的房子"，这就是符号引用，我们不知道具体房子的地址，但是我们明确知道有这么一所房子

**Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。**



#### 初始化

类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。

##### 常量值

被final static修饰的基本类型和字符串，会被编译器标记为常量值（ConstantValue），其初始化直接由虚拟机完成

#### <clinit>方法

除此之外的其他赋值操作和静态代码块中的代码，会被编译器置入< clinit >方法中，Java虚拟机会通过锁来保证< clinit > 方法只执行一次

JVM 规范枚举了下述多种触发类初始化的情况：

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；（实际例子就是著名的单例模式中的延迟初始化的写法）
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。









#### 